variables:
  - group: global
  - group: NuGetOrg
  - name: solution
    value: "**/*.sln"
  - name: buildConfiguration
    value: 'Release'

trigger:
  tags:
    include:
      - '*'
  batch: 'true'
  branches:
    include:
      - main
      - features/*
  paths:
    exclude:
      - README.md

pr:
  autoCancel: 'true'
  branches:
    include:
      - main

resources:
  - repo: self
    fetchDepth: '0'

#######################################################################################################
# VERSION
#
stages:
  - stage: version
    displayName: Version stage
    jobs:
      - job: version
        displayName: Version
        variables:
          MinVerDefaultPreReleaseIdentifiers: preview.0
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: '0'

          - task: UseDotNet@2
            displayName: Use .NET SDK
            condition: succeeded()
            inputs:
              version: '9.0.x'
              performMultiLevelLookup: true
              includePreviewVersions: false

          - bash: |
              export ASPNETCORE_ENVIRONMENT=Development
              whereis dotnet
              /usr/bin/dotnet --info
            displayName: Inspect environment
            condition: succeeded()

          - task: DotNetCoreCLI@2
            displayName: 'Install version tool'
            inputs:
              command: 'custom'
              custom: 'tool'
              arguments: 'install --global minver-cli --version 4.3.0'

          - powershell: |
              $version = $(minver -v d)
              # Force a pre-release suffix if on main, because of pre-release dependencies
              if ($env:BUILD_SOURCEBRANCH -eq "refs/heads/main") {
                  $version = "$version-preview"
              }
              $buildName = "$version"
              Write-Host "##vso[build.updatebuildnumber]$buildName"
              Write-Host "##vso[task.setvariable variable=BUILD_VERSION;isOutput=true]$buildName"
            displayName: Calculate version
            name: CalculateVersion

          - powershell: |
              Get-ChildItem Env:
            displayName: Show environment variables

  #######################################################################################################
  # BUILD & PACKAGE
  #
  - stage: build
    displayName: Build & Package stage
    dependsOn: [ version ]
    jobs:
      - job: build
        displayName: Build & Package Templates
        pool:
          vmImage: 'ubuntu-latest'
        variables:
          NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          BUILD_VERSION: $[ stageDependencies.version.version.outputs['CalculateVersion.BUILD_VERSION'] ]
        steps:
          - checkout: self
            fetchDepth: '0'

          - task: UseDotNet@2
            displayName: Use .NET SDK
            condition: succeeded()
            inputs:
              version: '9.0.x'
              performMultiLevelLookup: true
              includePreviewVersions: false

          - bash: |
              export ASPNETCORE_ENVIRONMENT=Development
              whereis dotnet
              /usr/bin/dotnet --info
            displayName: Inspect environment
            condition: succeeded()

          # Restore NuGet packages
          - task: DotNetCoreCLI@2
            displayName: Dotnet restore (nuget)
            condition: succeeded()
            inputs:
              command: restore
              verbosityRestore: Normal

          # Template validation - check if template.json files are valid
          - bash: |
              echo "Validating template configuration files..."
              find . -name "template.json" -type f | while read template; do
                echo "Validating: $template"
                if ! python3 -m json.tool "$template" > /dev/null; then
                  echo "Invalid JSON in template: $template"
                  exit 1
                fi
                echo "✓ Valid: $template"
              done
            displayName: Validate template configurations
            condition: succeeded()

          # Test template installation and creation
          - bash: |
              echo "Testing template installation..."
              dotnet new install .

              echo "Listing installed templates..."
              dotnet new list | grep -E "(devkitsolution|devkitmodule)" || echo "Templates not found in list"

              echo "Testing solution template creation..."
              mkdir -p test-output/test-solution
              cd test-output/test-solution
              dotnet new devkitsolution --SolutionName TestSolution --ModuleName TestCore

              # Verify that src folder structure was created correctly
              if [ -d "src" ]; then
                echo "✓ src folder created successfully"
                ls -la src/
              else
                echo "✗ src folder missing!"
                exit 1
              fi

              if [ -d "src/Modules" ]; then
                echo "✓ src/Modules folder created successfully"
              else
                echo "✗ src/Modules folder missing!"
                exit 1
              fi

              if [ -d "src/Presentation.Web.Server" ]; then
                echo "✓ src/Presentation.Web.Server folder created successfully"
              else
                echo "✗ src/Presentation.Web.Server folder missing!"
                exit 1
              fi

              echo "Template tests completed successfully"
            displayName: Test template functionality
            condition: succeeded()

          # Template security validation
          - task: Bash@3
            displayName: Template security validation
            continueOnError: true
            inputs:
              targetType: 'inline'
              script: |
                echo "Performing template security validation..."
                if grep -r -i "password\|secret\|key\|token" . --include="*.cs" --include="*.json" --include="*.config" --exclude-dir=".git" --exclude="azure-pipelines.yml"; then
                  echo "Warning: Potential sensitive information found in templates"
                fi
                echo "Template security validation completed"

          # Clean up test directories before packaging
          - bash: |
              echo "Cleaning up test directories..."
              rm -rf test-output/
              echo "Test directories cleaned"
            displayName: Clean test directories
            condition: succeeded()

          # Update version in csproj file
          - bash: |
              echo "Updating version in csproj file..."
              echo "Original version:"
              grep "<Version>" BridgingIT.DevKit.Templates.csproj
              grep "<PackageVersion>" BridgingIT.DevKit.Templates.csproj

              # Update Version, AssemblyVersion, FileVersion, PackageVersion
              sed -i "s|<Version>.*</Version>|<Version>$(BUILD_VERSION)</Version>|g" BridgingIT.DevKit.Templates.csproj
              sed -i "s|<AssemblyVersion>.*</AssemblyVersion>|<AssemblyVersion>$(BUILD_VERSION).0</AssemblyVersion>|g" BridgingIT.DevKit.Templates.csproj
              sed -i "s|<FileVersion>.*</FileVersion>|<FileVersion>$(BUILD_VERSION).0</FileVersion>|g" BridgingIT.DevKit.Templates.csproj
              sed -i "s|<PackageVersion>.*</PackageVersion>|<PackageVersion>$(BUILD_VERSION)</PackageVersion>|g" BridgingIT.DevKit.Templates.csproj

              echo "Updated version:"
              grep "<Version>" BridgingIT.DevKit.Templates.csproj
              grep "<PackageVersion>" BridgingIT.DevKit.Templates.csproj
            displayName: Update csproj version
            condition: succeeded()

          # Create NuGet package using csproj
          - task: DotNetCoreCLI@2
            displayName: Package pack
            condition: |
              and
              (
                succeeded(),
                or
                (
                  eq(variables['Build.SourceBranch'], 'refs/heads/main'),
                  contains(variables['Build.SourceBranch'], 'refs/tags')
                )
              )
            inputs:
              command: 'pack'
              configuration: $(buildConfiguration)
              projects: 'BridgingIT.DevKit.Templates.csproj'
              packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
              arguments: '--no-build --nologo --include-symbols'
              verbosityPack: Normal

          # Push to NuGet.org
          - task: DotNetCoreCLI@2
            displayName: Package push (nuget)
            condition: |
              and
              (
                succeeded(),
                or
                (
                  eq(variables['Build.SourceBranch'], 'refs/heads/main'),
                  contains(variables['Build.SourceBranch'], 'refs/tags')
                )
              )
            inputs:
              command: custom
              custom: nuget
              arguments: >
                push $(Build.ArtifactStagingDirectory)/packages/*.nupkg
                -s https://api.nuget.org/v3/index.json
                -k $(NugetOrgApiKey)
                --skip-duplicate

          # Publish artifacts
          - task: PublishPipelineArtifact@1
            displayName: Publish package artifacts
            condition: |
              and
              (
                succeeded(),
                or
                (
                  eq(variables['Build.SourceBranch'], 'refs/heads/main'),
                  contains(variables['Build.SourceBranch'], 'refs/tags')
                )
              )
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/packages"
              artifactName: packages

          # Clean up test installations
          - bash: |
              echo "Cleaning up template installations..."
              dotnet new uninstall BridgingIT.DevKit.Templates || true
              dotnet new uninstall BridgingIT.DevKit.Solution.Template || true
              dotnet new uninstall . || true
            displayName: Cleanup template installations
            condition: always()
            continueOnError: true