variables:
  - name: solution
    value: 'BridgingIT.DevKit.Examples.GettingStarted.slnx'
  - name: buildPlatform
    value: 'Any CPU'
  - name: buildConfiguration
    value: 'Release'

trigger:
  tags:
    include:
      - '*'
  batch: true
  branches:
    include:
      - main
      - features/*
  paths:
    exclude:
      - README.md
      - .gitignore
      - docs/*

pr:
  autoCancel: true
  branches:
    include:
      - main

stages:
- stage: Version
  displayName: 'ðŸ·ï¸ Calculate Version'
  jobs:
  - job: Version
    displayName: Generate Semantic Version
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self  # Needed for git history
      fetchDepth: 0

    - task: UseDotNet@2
      displayName: Use .NET SDK
      inputs:
        version: '9.0.x'
        includePreviewVersions: true

    - pwsh: |
        $env:ASPNETCORE_ENVIRONMENT = 'Development'
        dotnet --info
        Get-ChildItem Env: | Sort-Object Name | Format-Table -AutoSize
      displayName: Inspect environment
      condition: succeeded()

    - script: dotnet tool restore
      displayName: Restore .NET tools

    - pwsh: |
        $version = $(dotnet minver -v d -p preview.0)
        $buildName = "$version"
        Write-Host "##vso[build.updatebuildnumber]$buildName"
        Write-Host "##vso[task.setvariable variable=BUILD_VERSION;isOutput=true]$buildName"
      displayName: Calculate version
      name: setVersion

- stage: Build
  displayName: 'ðŸ—ï¸ Build Application'
  dependsOn: ['Version']
  variables:
    BUILD_VERSION: $[ stageDependencies.Version.CalculateVersion.outputs['setVersion.BUILD_VERSION'] ]
  jobs:
  - job: Build
    displayName: Build Application
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self  # Needed for source code
      fetchDepth: 0

    - task: UseDotNet@2
      displayName: Use .NET SDK
      inputs:
        version: '9.0.x'
        includePreviewVersions: true

    - script: dotnet tool restore
      displayName: Restore .NET tools

    - task: DotNetCoreCLI@2
      displayName: Restore packages
      inputs:
        command: 'restore'
        projects: '$(solution)'
        feedsToUse: 'select'

    - task: DotNetCoreCLI@2
      displayName: Build Solution
      inputs:
        command: 'build'
        projects: '$(solution)'
        arguments: '--configuration $(buildConfiguration) --no-restore'

- stage: Test
  displayName: 'ðŸ§ª Run Tests'
  dependsOn: ['Build']
  jobs:
  - job: Test
    displayName: Run Tests
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self  # Needed for docker-compose.yml
      fetchDepth: 0

    - task: UseDotNet@2
      displayName: Use .NET SDK
      inputs:
        version: '9.0.x'
        includePreviewVersions: true

    - script: dotnet tool restore
      displayName: Restore .NET tools

    - pwsh: |
        docker compose up -d
        docker ps -a
      displayName: Docker start containers

    # - task: Bash@3
    #   displayName: 'Vulnerability scan (nuget)'
    #   continueOnError: true
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       dotnet list $(Build.SourcesDirectory)/$(solution) package --vulnerable --include-transitive 2>&1 | tee build.log
    #       test `grep -cm 1 'has the following vulnerable packages' build.log` = 0

    # - pwsh: |
    #     # Run the dotnet command and capture output to build.log
    #     $output = dotnet list "$(Build.SourcesDirectory)/$(solution)" package --vulnerable --include-transitive 2>&1
    #     $output | Out-File -FilePath "build.log"

    #     # Check if the output contains the phrase "has the following vulnerable packages"
    #     $vulnerable = Select-String -Path "build.log" -Pattern "has the following vulnerable packages" -Quiet

    #     if ($vulnerable) {
    #       Write-Host "Vulnerabilities found in NuGet packages."
    #       exit 1  # Exit with a non-zero code to indicate failure
    #     } else {
    #       Write-Host "No vulnerabilities found in NuGet packages."
    #     }
    #   displayName: 'Vulnerability scan (nuget)'
    #   continueOnError: true

    - task: DotNetCoreCLI@2
      displayName: Restore packages
      inputs:
        command: 'restore'
        projects: '$(solution)'
        feedsToUse: 'select'

    - task: DotNetCoreCLI@2
      displayName: Run Unit Tests
      continueOnError: false
      inputs:
        command: 'test'
        projects: "**/*UnitTests*/*.csproj"
        arguments: '--configuration $(buildConfiguration) --no-restore --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura,opencover'

    - task: DotNetCoreCLI@2
      displayName: Run Integration Tests
      continueOnError: false
      inputs:
        command: 'test'
        projects: "**/*IntegrationTests*/*.csproj"
        arguments: '--configuration $(buildConfiguration) --no-restore --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura,opencover'

    - task: PublishCodeCoverageResults@2
      displayName: Publish Code Coverage
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
        failIfCoverageEmpty: false

    - pwsh: |
        # Stop compose services if docker compose is available
        if (Get-Command docker -ErrorAction SilentlyContinue) {
          try {
            docker compose stop 2>$null
          } catch { Write-Host "docker compose stop failed or not available. Continuing..." }
        } else {
          Write-Host "Docker not found. Skipping compose stop."
        }
        # Stop all containers (if any)
        $all = (docker ps -aq) 2>$null
        if ($LASTEXITCODE -ne 0 -or -not $all) {
          Write-Host "No containers to stop."
        } else {
          docker stop $all 2>$null | Out-Null
        }
        # Remove all containers (if any)
        $all = (docker ps -aq) 2>$null
        if ($LASTEXITCODE -ne 0 -or -not $all) {
          Write-Host "No containers to remove."
        } else {
          docker rm $all 2>$null | Out-Null
        }
      displayName: Docker cleanup
      condition: always()

- stage: Release
  displayName: 'ðŸš€ Release'
  condition: >-
    and(
      succeeded(),
      or(
        eq(variables['Build.SourceBranch'], 'refs/heads/main'),
        startsWith(variables['Build.SourceBranch'], 'refs/tags/')
      )
    )
  dependsOn:
  - Test
  - ${{ if and(eq(variables['Build.SourceBranch'], 'refs/heads/main'), ne(variables['sonarProjectKey'], ''), ne(variables['sonarProjectName'], '')) }}:
    - CodeAnalysis
  variables:
    BUILD_VERSION: $[ stageDependencies.Version.CalculateVersion.outputs['setVersion.BUILD_VERSION'] ]
  jobs:
  - job: Release
    displayName: Publish Application
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self  # Add Git context for MinVer
      fetchDepth: 0

    - task: UseDotNet@2
      displayName: 'Use .NET SDK'
      inputs:
        version: '9.0.x'
        includePreviewVersions: true

    - script: dotnet tool restore
      displayName: Restore .NET tools

    - task: DotNetCoreCLI@2
      displayName: Restore packages
      inputs:
        command: 'restore'
        projects: '$(solution)'
        feedsToUse: 'select'

    - task: DotNetCoreCLI@2
      displayName: Create Web App Package
      inputs:
        command: 'publish'
        publishWebProjects: false # prevents auto detection of projects
        projects: '$(Build.SourcesDirectory)/src/Presentation.Web.Server/Presentation.Web.Server.csproj'
        arguments: >-
          --configuration $(buildConfiguration)
          --no-restore
          --output $(Build.ArtifactStagingDirectory)/webapp
        zipAfterPublish: false

    # - pwsh: |
    #     $sourcePath = "$(Build.ArtifactStagingDirectory)/Presentation.Web.Server.zip"
    #     if (Test-Path $sourcePath) {
    #       Rename-Item -Path $sourcePath -NewName "Presentation.Web.Server-$(Build.BuildNumber).zip"
    #     } else {
    #       Write-Host "File $sourcePath not found, skipping rename."
    #     }
    #   displayName: 'Rename Artifact with version'

    - task: PublishBuildArtifacts@1
      displayName: Publish Artifact - Web App
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/webapp/Presentation.Web.Server'
        artifactName: 'webapp'
        publishLocation: 'Container'

    - task: DotNetCoreCLI@2
      displayName: Generate EF Migration Script
      inputs:
        command: 'custom'
        custom: 'ef'
        arguments: 'migrations script --configuration $(buildConfiguration) --context CoreModuleDbContext --output $(Build.ArtifactStagingDirectory)/sql/migrations-core.sql --idempotent --project $(Build.SourcesDirectory)/src/Modules/CoreModule/CoreModule.Infrastructure/CoreModule.Infrastructure.csproj --startup-project $(Build.SourcesDirectory)/src/Presentation.Web.Server/Presentation.Web.Server.csproj --verbose'

    - task: PublishBuildArtifacts@1
      displayName: Publish Artifact - EF Migration Scripts
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/sql'
        artifactName: 'sql'
        publishLocation: 'Container'