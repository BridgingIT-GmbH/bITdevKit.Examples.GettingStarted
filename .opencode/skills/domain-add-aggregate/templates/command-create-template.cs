// ============================================================================
// TEMPLATE: Create Command for [Entity] Aggregate
// ============================================================================
// PURPOSE:
//   Defines a command for creating a new aggregate instance with validation rules.
//   Commands encapsulate intent and are processed by handlers.
//
// PLACEHOLDERS TO REPLACE:
//   [Module]       - Module name (e.g., CoreModule)
//   [Entity]       - Aggregate root name (e.g., Customer, Product, Order)
//   [Property]     - Property names to validate (e.g., FirstName, LastName, Email)
//
// USAGE:
//   1. Replace all placeholders with actual values
//   2. Place in: src/Modules/[Module]/[Module].Application/Commands/
//   3. File name: [Entity]CreateCommand.cs
//   4. Add/remove validation rules based on your aggregate's properties
//   5. Invoked from Presentation layer endpoints: await requester.SendAsync(new [Entity]CreateCommand(model))
//
// RELATED PATTERNS:
//   - RequestBase<T>: bITdevKit base class for CQRS commands/queries
//   - AbstractValidator<T>: FluentValidation for input validation
//   - [Entity]CreateCommandHandler: Processes this command
// ============================================================================

namespace BridgingIT.DevKit.Examples.GettingStarted.Modules.[Module].Application;

using BridgingIT.DevKit.Examples.GettingStarted.Modules.[Module].Domain.Model;

/// <summary>
/// Command to create a new <see cref="[Entity]"/> Aggregate.
/// </summary>
/// <remarks>
/// This command follows the CQRS pattern:
/// - Represents user intent to create a new aggregate
/// - Contains DTO model with all required data
/// - Validation is performed via FluentValidation rules
/// - Processed by <see cref="[Entity]CreateCommandHandler"/>
/// </remarks>
public class [Entity]CreateCommand([Entity]Model model) : RequestBase<[Entity]Model>
{
    /// <summary>
    /// Gets or sets the Model (<see cref="[Entity]Model"/>) that contains data for the Aggregate to create.
    /// </summary>
    public [Entity]Model Model { get; set; } = model;

    /// <summary>
    /// Validation rules for <see cref="[Entity]CreateCommand"/> using FluentValidation.
    /// Executes before the handler via ValidationPipelineBehavior.
    /// </summary>
    public class Validator : AbstractValidator<[Entity]CreateCommand>
    {
        public Validator()
        {
            // RULE: Model must not be null
            this.RuleFor(c => c.Model)
                .NotNull()
                .WithMessage("Model is required.");

            // RULE: ID must be empty for new entities (generated by database)
            this.RuleFor(c => c.Model.Id)
                .MustBeDefaultOrEmptyGuid()
                .WithMessage("ID must be empty for new entities.");

            // ================================================================
            // ADD PROPERTY-SPECIFIC VALIDATION RULES BELOW
            // ================================================================
            // Example validation rules (customize based on your aggregate):

            // this.RuleFor(c => c.Model.[Property])
            //     .NotNull().NotEmpty()
            //     .WithMessage("[Property] must not be empty.");
            //
            // this.RuleFor(c => c.Model.[Property])
            //     .MaximumLength(256)
            //     .WithMessage("[Property] must not exceed 256 characters.");
            //
            // this.RuleFor(c => c.Model.[Property])
            //     .EmailAddress()
            //     .WithMessage("[Property] must be a valid email address.");
            //
            // this.RuleFor(c => c.Model.[Property])
            //     .GreaterThan(0)
            //     .WithMessage("[Property] must be greater than zero.");

            // ================================================================
            // VALIDATION STRATEGY
            // ================================================================
            // FluentValidation rules handle:
            //   - Structural validation (not null, proper format, length limits)
            //   - Data type validation (email format, numeric ranges)
            //   - Basic business rules (required fields, format constraints)
            //
            // Domain layer handles:
            //   - Complex business invariants (aggregate consistency)
            //   - Cross-entity rules (uniqueness checks via Rule pattern)
            //   - State transitions (status changes, lifecycle rules)
        }
    }
}

// ============================================================================
// KEY PATTERNS DEMONSTRATED
// ============================================================================
//
// 1. PRIMARY CONSTRUCTOR:
//    - public class [Entity]CreateCommand([Entity]Model model) : RequestBase<[Entity]Model>
//    - Concise parameter declaration
//
// 2. REQUESTBASE<T> INHERITANCE:
//    - Base class from bITdevKit for CQRS commands/queries
//    - T = return type (typically [Entity]Model for create operations)
//    - Provides pipeline support (validation, retry, timeout, logging)
//
// 3. NESTED VALIDATOR CLASS:
//    - Automatically discovered by FluentValidation
//    - Executed by ValidationPipelineBehavior before handler
//    - Fails fast if validation errors occur (Result<T> with validation errors)
//
// 4. FLUENTVALIDATION RULES:
//    - RuleFor(c => c.Property): Targets specific property
//    - NotNull(), NotEmpty(), MaximumLength(): Built-in validators
//    - MustBeDefaultOrEmptyGuid(): Custom validator extension (bITdevKit)
//    - WithMessage(): Custom error message
//
// 5. COMMAND NAMING CONVENTION:
//    - [Entity][Action]Command (e.g., CustomerCreateCommand)
//    - Action: Create, Update, Delete, or specific operation
//
// USAGE EXAMPLES:
//
//   // From Presentation layer (Minimal API endpoint):
//   group.MapPost("",
//       async ([FromServices] IRequester requester,
//              [FromBody] [Entity]Model model, CancellationToken ct)
//              => (await requester
//                   .SendAsync(new [Entity]CreateCommand(model), cancellationToken: ct))
//                   .MapHttpCreated(v => $"/api/[module]/[entities]/{v.Id}"));
//
//   // From Application layer (another handler/service):
//   var result = await requester.SendAsync(
//       new [Entity]CreateCommand(model),
//       cancellationToken: cancellationToken);
//
//   if (result.IsSuccess)
//   {
//       var created[Entity] = result.Value;
//       // ... use the created entity
//   }
//
// ============================================================================
